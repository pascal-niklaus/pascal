% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/diff_shading.R
\name{addpoly}
\alias{addpoly}
\alias{flushpoly}
\alias{newpoly}
\title{Shade difference between two lines}
\usage{
addpoly(mem, x, y1, y2)

flushpoly(mem)

newpoly(col = NULL, angle = NULL, density = NULL, lwd = NULL, lty = NULL)
}
\arguments{
\item{mem}{list structure passing 'memory' parameters between calls. 
Must not be modified by used.}

\item{x}{X coordinate of points (x,y1) and (x,y2)}

\item{y1}{Y coordinate of first line}

\item{y2}{Y coordinate of second line}

\item{col}{vector of 2, indicating color for y1>y2 and y1<y2}

\item{angle}{vector of 2, indicating hatching angle}

\item{density}{vector of 2, indicating density of shading lines, in lines per inch, 
for y1>y2 and y1<y2. NA indicates no shading}

\item{lwd}{vector of 2 with line width of polygons and shading, for y1>y2 and y1<y2}

\item{lty}{vector of 2 with line type of polygons, for y1>y2 and y1<y2}
}
\value{
list structure that should be passed as \code{mem} parameter to the next
        call of \code{addpoly} or \code{flushpoly}
}
\description{
This set of functions provides a way to shade the area between two lines,
with different patterns or colors depending on which line is on top.
}
\details{
In essence, a plot is started by calling \code{newpoly}. Then, \code{addpoly} is 
repeatedly called, passing the values \code{x} plus \code{y1} and \code{y2}. 
These calls must be in order of ascending \code{x}, i.e. 'left to right'. At the end,
the function \code{flushpoly} is called to draw the final polygons.
\code{addpoly} keeps accumulating coordinates until the two lines cross, in which case
the intersection is computed, the polygon plotted, and a new polygon started.
Data between repeated calls is passed as 'memory' in a list structure \code{mem}.
Parameters defining the plots can be passed to \code{newpoly} when this initial
structure is created.
}
\examples{
par(mfrow=c(1,2))
d<-data.frame(x=seq(0,2*pi,len=20))
d$y1 <- sin(d$x)
d$y2 <- 1.5*cos(2*d$x)-.5
plot(rep(d$x,2),c(d$y1,d$y2))
mem <- newpoly()
for(i in 1:nrow(d)) 
  mem<-addpoly(mem,d$x[i],d$y1[i],d$y2[i])
mem<-flushpoly(mem)
plot(rep(d$x,2),c(d$y1,d$y2))
mem <- newpoly(col=c("red","blue"),density=NA,lwd=1,lty=0)
for(i in 1:nrow(d)) 
  mem<-addpoly(mem,d$x[i],d$y1[i],d$y2[i])
flushpoly(mem)
}
\author{
Pascal Niklaus \email{pascal.niklaus@ieu.uzh.ch}
}
